---
id: chapter2-topics
title: "Chapter 2: Nodes, Topics, and Publishers/Subscribers"
sidebar_label: "Chapter 2: Nodes & Topics"
sidebar_position: 3
description: "Explore the core of ROS 2 communication: nodes, topics, publishers, and subscribers. Understand the pub-sub pattern and Quality of Service (QoS) settings."
keywords: [ros2, nodes, topics, publishers, subscribers, pub-sub, communication, std_msgs, geometry_msgs, sensor_msgs, qos]
---

# Chapter 2: Nodes, Topics, and Publishers/Subscribers

## The Robotic Nervous System: How Robots Communicate

In the previous chapter, you successfully installed ROS 2 and explored basic CLI commands. Now, it's time to understand the fundamental building blocks of ROS 2: **nodes** and **topics**. These concepts form the "nervous system" that allows different parts of your robot's software to communicate and coordinate actions, much like how neurons communicate in a biological brain.

This chapter will deep dive into the publish-subscribe (pub-sub) communication pattern, which is the most common way data flows in a ROS 2 system. We'll also introduce you to **Quality of Service (QoS)** settings, which allow you to fine-tune the reliability and behavior of your communication.

### Learning Outcomes

By the end of this chapter, you will be able to:

-   **Explain** the ROS 2 node architecture and how nodes communicate via topics.
-   **Create** a Python publisher node that sends messages to a topic at a specified rate.
-   **Create** a subscriber node that receives and processes messages from a topic.
-   **Configure** Quality of Service (QoS) settings for reliable communication.

---

## ROS 2 Node Architecture and Pub-Sub Pattern (FR-005)

At the heart of every ROS 2 application are **nodes**. A node is simply an executable process that performs a specific task. In a robot, you might have a node for reading LIDAR data, another for controlling motors, and yet another for processing camera images.

Nodes communicate with each other primarily through **topics** using a **publish-subscribe (pub-sub)** communication model. This model promotes a highly decoupled architecture, meaning nodes don't need to know about each other's existence directly.

### Decoupling with Topics

Imagine a traditional system where a LIDAR sensor directly calls a function in a navigation module to send data. This creates a tight coupling: if the navigation module changes its function signature, the LIDAR sensor node needs to be updated. If a new module needs LIDAR data, the LIDAR node needs to be modified to send data to two places.

In the ROS 2 pub-sub model:

-   A **publisher** node sends messages to a named **topic**.
-   A **subscriber** node listens for messages on that same topic.

Publishers don't know which subscribers are listening, and subscribers don't know which publishers are sending. They only interact with the topic. This makes your robot software modular, flexible, and scalable.

```mermaid
graph TD
    A[Lidar Node (Publisher)] --Publishes LaserScan--> B[/scan Topic]
    B --Subscribes to LaserScan--> C[Obstacle Detection Node (Subscriber)]
    B --Subscribes to LaserScan--> D[Mapping Node (Subscriber)]
    E[Controller Node (Publisher)] --Publishes Twist--> F[/cmd_vel Topic]
    F --Subscribes to Twist--> G[Robot Base Node (Subscriber)]
```

**Key benefits of the pub-sub pattern:**

-   **Decoupling**: Nodes operate independently.
-   **Scalability**: Easily add new publishers or subscribers without modifying existing nodes.
-   **Flexibility**: Multiple subscribers can listen to the same data stream, or multiple publishers can send to the same topic.

---

## ROS 2 Message Types (FR-009)

Messages are the data structures exchanged over topics. ROS 2 provides a rich set of predefined message types for common robotics data, but you can also define your own custom messages.

### Standard Message Types

ROS 2 categorizes messages into various packages, with some of the most common being:

-   `std_msgs`: Basic, primitive data types (e.g., `String`, `Int32`, `Bool`).
-   `geometry_msgs`: Geometric primitives (e.g., `Point`, `Vector3`, `Quaternion`, `Twist` for velocity commands).
-   `sensor_msgs`: Sensor-specific data (e.g., `Image`, `LaserScan`, `Imu`).

### Inspecting Message Types with `ros2 interface show`

You can inspect the structure of any message type using the `ros2 interface show` CLI tool:

```bash
ros2 interface show std_msgs/msg/String
```

Output:
```
# Single string message
string data
```

This tells you that a `std_msgs/msg/String` message contains a single field named `data` of type `string`.

Now try with a more complex message like `geometry_msgs/msg/Twist`:

```bash
ros2 interface show geometry_msgs/msg/Twist
```

Output:
```
# This expresses velocity in free space broken into its linear and angular parts.
geometry_msgs/Vector3 linear
  float64 x
  float64 y
  float64 z
geometry_msgs/Vector3 angular
  float64 x
  float64 y
  float64 z
```

This shows a `Twist` message has two sub-messages: `linear` and `angular`, both of type `geometry_msgs/Vector3`, which themselves contain `float64 x, y, z` fields.

---

## Creating a Publisher Node (FR-006)

A publisher node sends messages to a topic. We'll use Python and the `rclpy` library to create our first publisher.

### `minimal_publisher.py` (Example Code)

This example creates a node that publishes "Hello, ROS 2!" messages to the `/chatter` topic at a rate of 1 Hz.

```python
# File: module-1-ros2-fundamentals/src/ch2_talker_listener/minimal_publisher.py

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):

    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0
        self.get_logger().info('Minimal Publisher Node started.')

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello, ROS 2! {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher) # Keep node alive
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Code Breakdown**:

1.  **`import rclpy` and `from rclpy.node import Node`**: Import the necessary ROS 2 Python client library.
2.  **`from std_msgs.msg import String`**: Import the message type we'll be sending.
3.  **`class MinimalPublisher(Node):`**: Our node inherits from `rclpy.node.Node`, giving it all the basic ROS 2 functionality.
4.  **`super().__init__('minimal_publisher')`**: Initializes the node with a unique name (`minimal_publisher`).
5.  **`self.create_publisher(String, 'chatter', 10)`**: Creates a publisher. Arguments are: message type (`String`), topic name (`/chatter`), and queue size (10).
6.  **`self.create_timer(timer_period, self.timer_callback)`**: Sets up a timer that calls `timer_callback` every `timer_period` seconds.
7.  **`timer_callback(self)`**: This function is called by the timer. It creates a `String` message, populates its `data` field, and publishes it using `self.publisher_.publish(msg)`.
8.  **`rclpy.spin(minimal_publisher)`**: This function keeps the node alive, allowing its callbacks (like `timer_callback`) to be executed. It runs until the node is explicitly shut down (e.g., by pressing Ctrl+C).
9.  **`minimal_publisher.destroy_node()` and `rclpy.shutdown()`**: Essential for clean shutdown and releasing resources.

---

## Creating a Subscriber Node (FR-007)

A subscriber node listens to a topic and processes incoming messages. It uses a **callback function** that is executed every time a new message arrives.

### `minimal_subscriber.py` (Example Code)

This example creates a node that subscribes to the `/chatter` topic and prints any received messages to the console.

```python
# File: module-1-ros2-fundamentals/src/ch2_talker_listener/minimal_subscriber.py

import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,           # Message type
            'chatter',        # Topic name
            self.listener_callback, # Callback function
            10                # Queue size (QoS depth)
        )
        self.subscription  # prevent unused variable warning
        self.get_logger().info('Minimal Subscriber Node started.')

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Code Breakdown**:

1.  **`self.create_subscription(String, 'chatter', self.listener_callback, 10)`**: Creates a subscriber. Arguments are: message type (`String`), topic name (`/chatter`), the **callback function** (`self.listener_callback`) that gets executed when a message arrives, and queue size (10).
2.  **`listener_callback(self, msg)`**: This function receives the incoming message (`msg`) as its argument. Here, it simply logs the received data.

---

## Quality of Service (QoS) Settings (FR-008)

ROS 2, built on DDS (Data Distribution Service), provides powerful **Quality of Service (QoS)** policies that allow you to control how messages are delivered. These settings are crucial for defining reliability, latency, and data persistence for different types of robotics data.

When creating publishers and subscribers, you can specify QoS profiles. If you don't specify one, a default is used. However, for critical applications, customizing QoS is essential.

### Key QoS Profiles and Their Use Cases

| QoS Profile     | Reliability       | Durability          | History           | Liveliness    | Use Case                                         |
| :-------------- | :---------------- | :------------------ | :---------------- | :------------ | :----------------------------------------------- |
| **Default**     | Reliable          | Transient Local     | Keep Last (1)     | System Default| General purpose, simple communication             |
| **SensorData**  | Best Effort       | Volatile            | Keep Last (1)     | Automatic     | High-frequency sensor streams (e.g., LIDAR, camera) where losing a few messages is acceptable for low latency.  Old data is not relevant. |
| **Parameters**  | Reliable          | Transient Local     | Keep Last (1)     | System Default| Node configuration parameters. Must be reliably delivered and persistent. |
| **Services**    | Reliable          | Volatile            | Keep All (1)      | Automatic     | Request-response messages for service calls. Each request must be reliably delivered. |

-   **Reliability**: `Reliable` ensures every message is delivered (with retransmissions if needed). `Best Effort` prioritizes latency, dropping messages if network conditions are poor (common for real-time sensor data).
-   **Durability**: `Transient Local` means messages published *before* a subscriber connects might be received. `Volatile` means only messages published *after* a subscriber connects are received.
-   **History**: `Keep Last (X)` stores the last X messages. `Keep All` stores all messages until resource limits are reached.
-   **Liveliness**: How nodes detect if other nodes are still active.

### Example: Specifying QoS

You can specify a QoS profile directly in `create_publisher` or `create_subscription`:

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

# ... inside your node's __init__ ...

# Example: Sensor Data QoS Profile (Best Effort, Volatile, Keep Last 1)
sensor_qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=HistoryPolicy.KEEP_LAST,
    depth=1,
    durability=DurabilityPolicy.VOLATILE
)

self.sensor_publisher_ = self.create_publisher(
    LaserScan,                  # Message type
    'scan_topic',               # Topic name
    sensor_qos_profile          # Apply custom QoS profile
)

# Example: Reliable Parameter QoS Profile (for configuration messages)
param_qos_profile = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_LAST,
    depth=1,
    durability=DurabilityPolicy.TRANSIENT_LOCAL
)

self.param_subscriber_ = self.create_subscription(
    String,
    'config_topic',
    self.config_callback,
    param_qos_profile
)
```

Choosing the correct QoS settings is vital for your robot's performance and reliability. For high-frequency, real-time data like LIDAR scans, `Best Effort` is usually preferred to minimize latency. For critical commands or configuration, `Reliable` is a must.

---

## Exercise 1: Write a Minimal Publisher Node

**Goal**: Implement a Python publisher node that sends string messages.
**Type**: Python
**Difficulty**: Guided
**Estimated Time**: 30 minutes
**Starter Code**: Yes
**Solution Provided**: Yes

1.  In your `~/ros2_ws/src/module-1-ros2-fundamentals/src/ch2_talker_listener/` directory, create a new Python file named `minimal_publisher.py`.
2.  Copy the provided `minimal_publisher.py` code snippet from the "Creating a Publisher Node" section into your file.
3.  Ensure your `package.xml` in `~/ros2_ws/src/module-1-ros2-fundamentals/src/ch2_talker_listener/` has the necessary dependencies (`rclpy`, `std_msgs`). If not, add them.
4.  Open `setup.py` in the same package and add an entry point for your node:

    ```python
    # ... inside setup.py
    entry_points={
        'console_scripts': [
            'minimal_publisher = ch2_talker_listener.minimal_publisher:main',
        ],
    },
    # ...
    ```

5.  Navigate to your workspace root (`~/ros2_ws`) and build your package:

    ```bash
    colcon build --packages-select ch2_talker_listener
    source install/setup.bash
    ```

6.  Run your publisher node:

    ```bash
    ros2 run ch2_talker_listener minimal_publisher
    ```

    You should see it publishing messages to the `/chatter` topic.

7.  Open a **second terminal**, source your workspace, and use `ros2 topic echo /chatter` to verify the messages are being received.

---

## Exercise 2: Write a Subscriber Node and Verify with CLI

**Goal**: Implement a Python subscriber node and verify it receives messages from the publisher.
**Type**: Python
**Difficulty**: Guided
**Estimated Time**: 30 minutes
**Starter Code**: Yes
**Solution Provided**: Yes

1.  In the same `~/ros2_ws/src/ch2_talker_listener/` directory, create a new Python file named `minimal_subscriber.py`.
2.  Copy the provided `minimal_subscriber.py` code snippet from the "Creating a Subscriber Node" section into your file.
3.  Update your `setup.py` to include an entry point for the subscriber:

    ```python
    # ... inside setup.py
    entry_points={
        'console_scripts': [
            'minimal_publisher = ch2_talker_listener.minimal_publisher:main',
            'minimal_subscriber = ch2_talker_listener.minimal_subscriber:main',
        ],
    },
    # ...
    ```

4.  Rebuild your package and source the workspace:

    ```bash
    colcon build --packages-select ch2_talker_listener
    source install/setup.bash
    ```

5.  Open **two terminals**.
    -   In Terminal 1: Run your publisher node: `ros2 run ch2_talker_listener minimal_publisher`
    -   In Terminal 2: Run your subscriber node: `ros2 run ch2_talker_listener minimal_subscriber`

    You should see the subscriber printing messages received from the publisher.

---

## Exercise 3: Experiment with QoS Settings

**Goal**: Modify publisher/subscriber QoS settings and observe the impact.
**Type**: Python
**Difficulty**: Semi-guided
**Estimated Time**: 40 minutes
**Starter Code**: No
**Solution Provided**: Yes

1.  Create a new Python file `qos_experiment.py` in `~/ros2_ws/src/ch2_talker_listener/`.
2.  In this file, create a publisher and subscriber for the same topic (`/my_data`).
3.  Experiment with different QoS profiles. For example:
    -   Create a publisher with `ReliabilityPolicy.BEST_EFFORT` and a subscriber with `ReliabilityPolicy.RELIABLE`.
    -   Create a publisher with `DurabilityPolicy.VOLATILE` and a subscriber that connects *after* a few messages have been published.
4.  Observe when messages are lost or when subscribers miss initial messages.
5.  Document your findings in comments within your `qos_experiment.py` file.

:::tip Observation Challenge
If you have a way to simulate network packet loss (e.g., using `netem` on Linux), you can more clearly see the difference between `BEST_EFFORT` and `RELIABLE` policies. However, simply observing missed messages when a subscriber connects late is also a good start.
:::

---

## Troubleshooting Common Topic & Node Issues

### Issue: Subscriber not receiving messages

-   **Cause 1: Topic name mismatch**: Publisher and subscriber are using different topic names.
-   **Solution**: Double-check topic names in both nodes and use `ros2 topic list` and `ros2 topic info <topic_name>` to verify.

-   **Cause 2: Message type mismatch**: Publisher and subscriber are using different message types for the same topic.
-   **Solution**: Verify message types using `ros2 topic info <topic_name>` and `ros2 interface show <message_type>`.

-   **Cause 3: QoS mismatch**: Incompatible QoS settings between publisher and subscriber (e.g., `Reliable` publisher and `Best Effort` subscriber can cause issues, though `Best Effort` publisher and `Reliable` subscriber usually works).
-   **Solution**: Explicitly set identical, compatible QoS profiles for both ends of the communication. Start with the `Default` profile for both to rule this out.

-   **Cause 4: Node not spinning**: The `rclpy.spin()` call is missing or interrupted.
-   **Solution**: Ensure `rclpy.spin(node)` is called and the node is not prematurely destroyed. Use `try-except KeyboardInterrupt` for graceful shutdown, but ensure `spin` runs until an interrupt.

### Issue: Node crashes immediately

-   **Cause**: An error occurred during the node's initialization (`__init__` method) or immediately after `rclpy.spin()` is called.
-   **Solution**: Add `try-except` blocks around suspicious code sections in `__init__` to pinpoint the error. Check import statements for typos. Review the node's `setup.py` entry point.

### Issue: Performance issues or high latency on topics

-   **Cause**: Publishing too frequently, processing messages too slowly in callbacks, or using `Reliable` QoS for high-bandwidth sensor data.
-   **Solution**: For sensor data, consider `Best Effort` QoS. Optimize your callback functions for speed. Use `ros2 topic bw <topic_name>` to monitor topic bandwidth.

---

## Summary

This chapter introduced you to the core communication concepts in ROS 2. You learned that nodes are the computational units, and topics provide the decoupled messaging backbone using a publish-subscribe pattern. You also gained a foundational understanding of ROS 2 message types and how Quality of Service (QoS) policies dictate message delivery behavior.

With these fundamentals, you're now ready to start writing more complex Python nodes to control simulated robots and process real-time sensor data in the next chapter. The concepts of nodes and topics are central to all ROS 2 applications, so ensure you have a solid grasp of them before moving on.

**Next**: Proceed to **Chapter 3: Python Integration with rclpy** to bring your ROS 2 applications to life with code! â†’
